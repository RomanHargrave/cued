#define cc_Root_isa NULL

cc_class(Root,
    cc_method("init",  initRoot),
    cc_method("free",  freeRoot),
    cc_method("copy",  copyRoot),
    cc_method("error", errorRoot),
    )


// TODO:  should this use sizeof(cc_class_object), even though size is unused?
// should we set to -1, ha ha ?
//

cc_class_object MetaRoot = {
    NULL,
    NULL,
    "MetaRoot",
    sizeof(cc_vars_Root),
    0,
    NULL
};


#define cc_class_object(cls, ...) \
cc_construct_methods(Meta##cls, Meta##cls, __VA_ARGS__) \
cc_destruct_methods(Meta##cls) \
cc_class_object Meta##cls = { \
    NULL, \
    &cc_Meta##cls##_isa, \
    "Meta" #cls, \
    sizeof(cc_vars_##cls), \
    0, \
    NULL \
    };

        // TODO:  necessary check?  why optimize the case of looking up forward?
        if (strcmp2("forward", msg)) {

        (void) cc_msg(obj, "init");

    if (!is_ptr(argv[0]) && !is_obj(argv[0])) {
        return cc_msg(my, "error", by_str("wrong type to initVector for class \""),
            by_str(my->name), by_str("\""));
    }

cc_begin_meta_method(MetaRoot, initStatic)
    cc_arg_t rc = by_obj(NULL);
    int i;
    for (i = 0;  i < argc;  ++i) {
//      as_obj or as_ptr ?
//        cc_vars_Root *obj = (cc_vars_Root *) as_obj(argv[i]);
        cc_vars_Root *obj = (cc_vars_Root *) argv[i].u.p;
        obj->isa = my;
        rc = cc_msg(obj, "init");
    }
    return rc;
cc_end_method


    [cc_type_any] = "any",

    [cc_type_o]   = "object",
    [cc_type_p]   = "pointer",
    [cc_type_s]   = "string",

    [cc_type_sc]  = "signed char",
    [cc_type_h]   = "short",
    [cc_type_i]   = "int",
    [cc_type_l]   = "long",
    [cc_type_ll]  = "long long",

    [cc_type_uc]  = "unsigned char",
    [cc_type_uh]  = "unsigned short",
    [cc_type_ui]  = "unsigned int",
    [cc_type_ul]  = "unsigned long",
    [cc_type_ull] = "unsigned long long",

    [cc_type_c]   = "char",
    [cc_type_f]   = "float",
    [cc_type_d]   = "double"


    "any",

    "object",
    "pointer",
    "string",

    "signed char",
    "short",
    "int",
    "long",
    "long long",

    "unsigned char",
    "unsigned short",
    "unsigned int",
    "unsigned long",
    "unsigned long long",

    "char",
    "float",
    "double"
