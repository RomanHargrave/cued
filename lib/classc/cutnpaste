
typedef struct _cc_frame_t {

    cc_obj my;
    const char *msg;
    struct _cc_frame_t *prev;
    const char *fileName;
    int lineno;
    int argc;
    cc_arg_t *argv;

} cc_frame_t;

extern cc_frame_t *_cc_curr_frame;

    cc_frame_t _cc_next_frame = { obj, msg, _cc_curr_frame, __FILE__, __LINE__, sizeof(_cc_tmp_args) / sizeof(cc_arg_t), _cc_tmp_args }; \


cc_begin_meta_method(MetaAlloc, calloc)
    if (argc < 2) {
        return cc_error(by_str("too few arguments"));
    }
    return by_ptr(calloc(as_size_t(argv[0]), as_size_t(argv[1])));
cc_end_method


// cannot specify in C++ that the function should be inline for this module and extern in other modules
// (although one can make an extern function as a wrapper that calls the inline version of the function)
//
#if !defined(__cplusplus) && !defined(__SunOS)
inline
#endif

// if constant string folding is enabled, then compare string pointers before executing
// strcmp intrinsically
//
#if defined(__GNUC__) && defined(__OPTIMIZE__)

static inline int strcmp2(const char *a, const char *b)
{
    return (a == b) ? 0 : strcmp(a, b);
}

#else
#define strcmp2 strcmp
#endif


#define as(x, y) ((cc_type_##x == (y).t || cc_type_any == (y).t) ? ((y).u.x) : ( \
        fprintf(stderr, "fatal:  expected type \"%s\", but received type \"%s\" at line %d in file \"%s\"\n", \
        cc_type_names[cc_type_##x], cc_type_names[(y).t], __LINE__, __FILE__), abort(), 0))

#define cc_Root_isa NULL

cc_class(Root,
    cc_method("init",  initRoot),
    cc_method("free",  freeRoot),
    cc_method("copy",  copyRoot),
    cc_method("error", errorRoot),
    )


// TODO:  should this use sizeof(cc_class_object), even though size is unused?
// should we set to -1, ha ha ?  yes, that's what we did
//

cc_class_object MetaRoot = {
    NULL,
    NULL,
    "MetaRoot",
    sizeof(cc_vars_Root),
    0,
    NULL
};


#define cc_class_object(cls, ...) \
cc_construct_methods(Meta##cls, Meta##cls, __VA_ARGS__) \
cc_destruct_methods(Meta##cls) \
cc_class_object Meta##cls = { \
    NULL, \
    &cc_Meta##cls##_isa, \
    "Meta" #cls, \
    sizeof(cc_vars_##cls), \
    0, \
    NULL \
    };

        // TODO:  necessary check?  why optimize the case of looking up forward?
        if (strcmp2("forward", msg)) {

        (void) cc_msg(obj, "init");

    if (!is_ptr(argv[0]) && !is_obj(argv[0])) {
        return cc_msg(my, "error", by_str("wrong type to initVector for class \""),
            by_str(my->name), by_str("\""));
    }

cc_begin_meta_method(MetaRoot, initStatic)
    cc_arg_t rc = by_obj(NULL);
    int i;
    for (i = 0;  i < argc;  ++i) {
//      as_obj or as_ptr ?
//        cc_vars_Root *obj = (cc_vars_Root *) as_obj(argv[i]);
        cc_vars_Root *obj = (cc_vars_Root *) argv[i].u.p;
        obj->isa = my;
        rc = cc_msg(obj, "init");
    }
    return rc;
cc_end_method


    [cc_type_any] = "any",

    [cc_type_o]   = "object",
    [cc_type_p]   = "pointer",
    [cc_type_s]   = "string",

    [cc_type_sc]  = "signed char",
    [cc_type_h]   = "short",
    [cc_type_i]   = "int",
    [cc_type_l]   = "long",
    [cc_type_ll]  = "long long",

    [cc_type_uc]  = "unsigned char",
    [cc_type_uh]  = "unsigned short",
    [cc_type_ui]  = "unsigned int",
    [cc_type_ul]  = "unsigned long",
    [cc_type_ull] = "unsigned long long",

    [cc_type_c]   = "char",
    [cc_type_f]   = "float",
    [cc_type_d]   = "double"


    "any",

    "object",
    "pointer",
    "string",

    "signed char",
    "short",
    "int",
    "long",
    "long long",

    "unsigned char",
    "unsigned short",
    "unsigned int",
    "unsigned long",
    "unsigned long long",

    "char",
    "float",
    "double"
