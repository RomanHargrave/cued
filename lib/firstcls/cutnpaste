cc_begin_method(FcTreeCursor, remove)
    // hmm, remove sometimes finds the successor for you;  is it worth optimizing?
    FcTreeNode *next = TreeSuccessor(my->tree, my->curr);
cc_end_method


    // TODO: allocate theNewSubTree in this function (in two places?) (TreeUnbalancedInsert)
    // is finding the node already present a common use case?
    // could save the unused node for later in the tree?

    return my->curr ? my->curr->item : cc_null;


cc_begin_meta_method(alloc, MetaDbleList)
    cc_vars_DbleList *obj = as_obj(cc_msg_super("alloc"));
    if (obj) {
        obj->head.next = obj->head.prev = &obj->head;
    }
    return by_obj(obj);
cc_end_method


cc_begin_method(insertHead, DbleList)
    DbleListNode *node, *next;
    int i;

    for (i = 0;  i < argc;  ++i) {
        node = malloc(sizeof(DbleListNode));
        if (!node) {
            return cc_msg(my, "error", by_str("out of memory allocating list node"));
        }

        next = my->head.next;
        my->head.next = node;
        next->prev = node;

        node->next = next;
        node->prev = &my->head;
        node->item = as_obj(argv[i]);
    }

    return by_obj(my);
cc_end_method


cc_begin_method(insertTail, DbleList)
    DbleListNode *node, *prev;
    int i;

    for (i = 0;  i < argc;  ++i) {
        node = malloc(sizeof(DbleListNode));
        if (!node) {
            return cc_msg(my, "error", by_str("out of memory allocating list node"));
        }

        prev = my->head.prev;
        my->head.prev = node;
        prev->next = node;

        node->prev = prev;
        node->next = &my->head;
        node->item = as_obj(argv[i]);
    }

    return by_obj(my);
cc_end_method


// broken way of affixing
    int i;
    for (i = 0;  i < argc;  ++i) {
        my->curr = my->curr->next;
        if (!insertBefore(my->curr, as_obj(argv[i]))) {
            return cc_msg(my, "error", by_str("out of memory allocating list node"));
        }
    }


cc_begin_method(FcListCursor, remove)
    FcListNode *curr = my->curr;
    if (&my->list->head != curr) {
        my->curr = curr->next;
        return removeAndReturn(my->list, curr);
    } else {
        return by_obj(NULL);
    }
cc_end_method


static inline cc_arg_t getCurrent(cc_vars_FcListCursor *my)
{
    if (&my->list->head != my->curr) {
        return by_obj(my->curr->item);
    } else {
        return by_obj(NULL);
    }
}
