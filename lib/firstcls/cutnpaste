        // this does not have to be fatal:  could comment these lines and continue
        const char *msg = "unknown";
        cc_error(by_str("cannot remove item from empty list"));
        //cc_msg(my, "error", by_str("attempt to remove item from empty list"));

    ssize_t pre = 0;
                    len = as_ssize_t(argv[1]);
                    pre = as_ssize_t(argv[2]);
                    break;


#if 0
    len = as_int(cc_msg(obj, "length"));
    rc = memcmp(my->buffer, str, (my->length < len) ? my->length : len);
    if (!rc && my->length != len) {
        rc = (my->length < len) ? -1 : 1;
    }
#endif

    if (argc < 1) {
        return cc_msg(my, "error", by_str("too few arguments to \""), by_str(msg),
                      by_str("\" for class \""), by_str(my->isa->name), by_str("\""));
    }

// TODO:  should take int to terminate apply?


cc_begin_method(FcTreeCursor, remove)
    // hmm, remove sometimes finds the successor for you;  is it worth optimizing?
    FcTreeNode *next = TreeSuccessor(my->tree, my->curr);
cc_end_method


    // TODO: allocate theNewSubTree in this function (in two places?) (TreeUnbalancedInsert)
    // is finding the node already present a common use case?
    // could save the unused node for later in the tree?

    return my->curr ? my->curr->item : cc_null;


cc_begin_meta_method(alloc, MetaDbleList)
    cc_vars_DbleList *obj = as_obj(cc_msg_super("alloc"));
    if (obj) {
        obj->head.next = obj->head.prev = &obj->head;
    }
    return by_obj(obj);
cc_end_method


cc_begin_method(insertHead, DbleList)
    DbleListNode *node, *next;
    int i;

    for (i = 0;  i < argc;  ++i) {
        node = malloc(sizeof(DbleListNode));
        if (!node) {
            return cc_msg(my, "error", by_str("out of memory allocating list node"));
        }

        next = my->head.next;
        my->head.next = node;
        next->prev = node;

        node->next = next;
        node->prev = &my->head;
        node->item = as_obj(argv[i]);
    }

    return by_obj(my);
cc_end_method


cc_begin_method(insertTail, DbleList)
    DbleListNode *node, *prev;
    int i;

    for (i = 0;  i < argc;  ++i) {
        node = malloc(sizeof(DbleListNode));
        if (!node) {
            return cc_msg(my, "error", by_str("out of memory allocating list node"));
        }

        prev = my->head.prev;
        my->head.prev = node;
        prev->next = node;

        node->prev = prev;
        node->next = &my->head;
        node->item = as_obj(argv[i]);
    }

    return by_obj(my);
cc_end_method


// broken way of affixing
    int i;
    for (i = 0;  i < argc;  ++i) {
        my->curr = my->curr->next;
        if (!insertBefore(my->curr, as_obj(argv[i]))) {
            return cc_msg(my, "error", by_str("out of memory allocating list node"));
        }
    }


cc_begin_method(FcListCursor, remove)
    FcListNode *curr = my->curr;
    if (&my->list->head != curr) {
        my->curr = curr->next;
        return removeAndReturn(my->list, curr);
    } else {
        return by_obj(NULL);
    }
cc_end_method


static inline cc_arg_t getCurrent(cc_vars_FcListCursor *my)
{
    if (&my->list->head != my->curr) {
        return by_obj(my->curr->item);
    } else {
        return by_obj(NULL);
    }
}
