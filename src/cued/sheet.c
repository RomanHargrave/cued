//
// sheet.c
//
// Copyright (C) 2007,2008 Robert William Fuller <hydrologiccycle@gmail.com>
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#ifdef HAVE_CONFIG_H
#include "cued_config.h" // CUED_PACKAGE_VERSION
#endif
#include "macros.h"
#include "unix.h"
#include "cued.h" // CUED_PRODUCT_NAME
#include "dmalloc.h"

#define DO_NOT_WANT_PARANOIA_COMPATIBILITY
#include <cdio/cdio.h>
#include "cdio2.h"
#include "sheet.h"
#include "qsc.h"

#include <stdlib.h> // atoll


static int cued_lsn_to_ascii_for_cue(lsn_t lsn, char *ascii)
{
    // subtract the 2-second lead-in pre-gap for track 1
    lsn -= QSC_FPG;

    return qsc_lsn_to_ascii(lsn, ascii);
}


void cued_write_cuefile(
    rip_context_t *rip,
    const char *devName,
    track_t firstTrack,
    track_t lastTrack
    )
{
    PIT(char, devFileName);
    long long nmcn;
    int quoted, channels;
    track_t track;
    lsn_t firstTrackLsn;

    devFileName = noextname(devName);
    if (!devFileName) {
        cdio2_abort("out of memory creating FILE command for \"%s\"", devName);
    }

    // output disc level cue info
    //

    fprintf(rip->cueFile, "REM COMMENT Generated by " CUED_PRODUCT_NAME " v" CUED_PACKAGE_VERSION "\n");

    // some drives return garbage for the MCN, so try the sub-channel data first
    if (rip->mcn[0]) {
        fprintf(rip->cueFile, "CATALOG %s\n", rip->mcn);
    } else {
        char *mcn = cdio_get_mcn(rip->cdObj);
        if (mcn) {
            if ((nmcn = atoll(mcn))) {
                if (strchr(mcn, ' ')) {

                    // Nero is buggy, to say the least
                    fprintf(rip->cueFile, "CATALOG %013lld\n", nmcn);
                } else {
                    fprintf(rip->cueFile, "CATALOG %s\n", mcn);
                }
            }
            libc_free(mcn);
        }
    }

    cdio2_fprint_cd_text(rip->cueFile, rip->cdObj, 0, "");

    quoted = strchr(basename2(devFileName), ' ') ? 1 : 0;
    fprintf(rip->cueFile
        , "FILE %s%s.bin%s BINARY\n"
        , quoted ? "\"" : ""
        , basename2(devFileName)
        , quoted ? "\"" : ""
        );
    libc_free(devFileName);

    firstTrackLsn = cdio_get_track_lsn(rip->cdObj, 1);
    if (CDIO_INVALID_LSN == firstTrackLsn) {
        cdio2_abort("failed to get first sector number for first track");
    }

    for (track = firstTrack;  track <= lastTrack;  ++track) {

        lsn_t *ripLsn;
        lsn_t lsn, useLsn;
        track_flag_t flagrc;
        int preemp, copy, index, flags;
        char msfStr[ MSF_LEN + 1 ];

        if (TRACK_FORMAT_AUDIO != cdio_get_track_format(rip->cdObj, track)) {
            cdio_warn("track %02d is not an audio track; skipping track", track);
            continue;
        }

        channels = cdio2_get_track_channels(rip->cdObj, track);

        flagrc = cdio_get_track_preemphasis(rip->cdObj, track);
        if (CDIO_TRACK_FLAG_TRUE != flagrc && CDIO_TRACK_FLAG_FALSE != flagrc) {
            cdio_warn("failed to get pre-emphasis flag for track %02d; assuming no pre-emphasis", track);
            preemp = 0;
        } else {
            preemp = (CDIO_TRACK_FLAG_TRUE == flagrc) ? 1 : 0;
        }

        flagrc = cdio_get_track_copy_permit(rip->cdObj, track);
        if (CDIO_TRACK_FLAG_TRUE != flagrc && CDIO_TRACK_FLAG_FALSE != flagrc) {
            cdio_warn("failed to get copy permitted flag for track %02d; assuming no copy permitted", track);
            copy = 0;
        } else {
            copy = (CDIO_TRACK_FLAG_TRUE == flagrc) ? 1 : 0;
        }

        flags = rip->ripData[track].flags;
        if (TSTF(RIP_F_DATA_VALID, flags)) {
            if (!copy && TSTF(RIP_F_DATA_COPY_PERMITTED, flags)) {
                cdio_warn("Q sub-channel indicates copy is permitted for track %02d whereas TOC does not;  setting copy permitted", track);
                copy = 1;
            }
            if (!preemp && TSTF(RIP_F_DATA_PRE_EMPHASIS, flags)) {
                cdio_warn("Q sub-channel indicates pre-emphasis for track %02d whereas TOC does not;  setting pre-emphasis", track);
                preemp = 1;
            }
            if (2 == channels && TSTF(RIP_F_DATA_FOUR_CHANNELS, flags)) {
                cdio_warn("Q sub-channel indicates four channels for track %02d whereas TOC does not;  setting four channels", track);
                channels = 4;
            }
        }

        // output track level cue info
        //

        fprintf(rip->cueFile, "  TRACK %02d AUDIO\n", track);
        cdio2_fprint_cd_text(rip->cueFile, rip->cdObj, track, "    ");
        if (preemp || copy || (4 == channels)) {
            fprintf(rip->cueFile, "    FLAGS%s%s%s\n", copy ? " DCP" : "", (4 == channels) ? " 4CH" : "", preemp ? " PRE" : "");
        }

        if (rip->ripData[track].isrc[0]) {
            fprintf(rip->cueFile, "    ISRC %s\n", rip->ripData[track].isrc);
        }

        lsn = cdio_get_track_lsn(rip->cdObj, track);
        if (CDIO_INVALID_LSN == lsn) {
            cdio2_abort("failed to get first sector number for track %02d", track);
        }

        ripLsn = rip->ripData[track].indices;

        // don't use ripLsn[0] here because it is possible ripLsn[1] is set, although ripLsn[0] is not
        if (CDIO_INVALID_LSN != ripLsn[1]) {
            for (index = 0;  index < CUED_MAX_INDICES;  ++index) {

                useLsn = ripLsn[index];
                if (CDIO_INVALID_LSN == useLsn) {
                    if (!index) {

                        // this is the case where ripLsn[1] is set, but ripLsn[0] is not (no pre-gap)
                        continue;
                    } else {
                        break;
                    }
                }

                // what does it even mean for a pre-gap to have an index greater than the TOC? (index == 0)
                if (index <= 1 && useLsn > lsn) {
                    cdio_warn("index %02d from Q sub-channel for track %02d is greater than index from TOC (lsn=%d > lsn=%d); using TOC",
                        index, track, useLsn, lsn);
                    useLsn = lsn;
                }

                if (1 == track && !index && ripSilentPregap) {

                    // pregap for first track was silent; track 0 was deleted; use PREGAP directive in cuesheet
                    if (!cued_lsn_to_ascii_for_cue(firstTrackLsn, msfStr)) {
                        fprintf(rip->cueFile, "    PREGAP %s\n", msfStr);
                    } else {
                        cdio2_abort("failed to convert pre-gap for track %02d", track);
                    }
                } else {

                    // if pregap is silent, adjust index for the fact that pregap was not saved
                    if (ripSilentPregap) {
                        useLsn -= firstTrackLsn;
                    }

                    if (!cued_lsn_to_ascii_for_cue(useLsn, msfStr)) {
                        fprintf(rip->cueFile, "    INDEX %02d %s\n", index, msfStr);
                    } else {
                        cdio2_abort("failed to convert index %02d for track %02d", index, track);
                    }
                }
            }
        } else {
            useLsn = lsn;

            if (ripSilentPregap) {
                useLsn -= firstTrackLsn;
                if (1 == track) {
                    if (!cued_lsn_to_ascii_for_cue(firstTrackLsn, msfStr)) {
                        fprintf(rip->cueFile, "    PREGAP %s\n", msfStr);
                    } else {
                        cdio2_abort("failed to convert pre-gap for track %02d", track);
                    }
                }
            }

            if (!cued_lsn_to_ascii_for_cue(useLsn, msfStr)) {
                fprintf(rip->cueFile, "    INDEX %02d %s\n", 1, msfStr);
            } else {
                cdio2_abort("failed to convert index for track %02d", track);
            }
        }
    }

    if (rip->cueFile != stdout) {
        fclose(rip->cueFile);
    }
}
